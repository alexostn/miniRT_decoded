# Ambient (A)

**Format:**
```
A 0.2	255,255,255
▲  ▲    ▲ ▲ ▲
│  │    │ │ │
│  │    │ R,G,B Color (0-255)
│  │
│  ratio (0.0 - 1.0)
│
Identifier ("A" for ambient)
```



## Notes

- Change 0.2 to 0.0 → sphere should be very dark
- Change 0.2 to 1.0 → sphere should be bright even without light
- Change color 255,255,255 to 255,0,0 → entire scene should have reddish tint

а есть какойто простой способ перехватить открытый в моей программе рендер это наврное ppm, для того, чтобы потом сравнить при следующем рендере имея две картинки на убунту, или может открыть то что сейчас рендерится при помощи image viewer или ещё както чтобы осталась картинка и можно было со следующей сравнить , без вмешательства существенного или вообще в мой код
Если ваша программа miniRT выводит рендер в формате PPM (вероятно, в stdout), вы можете легко сохранить его в файл и сравнить с предыдущим рендером на Ubuntu без изменений в коде. Вот простой способ:

1. Сохранение рендера в файл
Запустите программу и перенаправьте вывод в файл:

./miniRT scene.rt > output1.ppm

Открытие PPM-изображения
PPM поддерживается многими viewers. Откройте файл командой:
eog output1.ppm

найди как моя прога выводит изображение во время рендера

---

**Ответ:**  
Чтобы узнать, как ваша программа miniRT выводит изображение во время рендера, найдите в исходном коде функции, связанные с выводом изображения. Обычно это функции, которые:

- Записывают данные в stdout (например, `write(1, ...)`, `printf`, `puts` и т.п.)
- Используют библиотеки для работы с окнами (например, MiniLibX: `mlx_put_image_to_window`, `mlx_new_image`, и т.д.)

Если при перенаправлении вывода (`./miniRT scene.rt > output1.ppm`) файл пустой, скорее всего, изображение выводится не в stdout, а напрямую в окно через графическую библиотеку (например, MiniLibX).  
В этом случае для сохранения изображения в файл ищите функции, которые создают или манипулируют изображением (image buffer), и проверьте, есть ли в коде функция для экспорта изображения в файл (например, собственная функция записи PPM/BMP или аналогичная).

**Рекомендация:**  
Просмотрите файлы с названиями вроде `image.c`, `render.c`, `display.c` или функции с именами, содержащими `save`, `export`, `write`, `ppm`, `bmp`, а также вызовы функций MiniLibX, чтобы понять, куда выводится изображение.

---

**Анализ Valgrind-лога:**  
Из Valgrind-отчёта видно, что изображение создаётся через функцию `image_create` (image.c), которая внутри вызывает `mlx_new_image` (MiniLibX).  
Далее, в стеке есть вызов `render` (render.c), а затем `main` (main.c).

**Что делать дальше:**  
1. Откройте файл `image.c` и найдите функцию `image_create`.  
2. Посмотрите, где вызывается `mlx_new_image` и как возвращается/используется созданное изображение.
3. В файле `render.c` найдите функцию `render` и посмотрите, как она работает с изображением.
4. Обычно после рендера изображение выводится на экран через `mlx_put_image_to_window`. Найдите этот вызов в проекте (например, с помощью `grep`).

**Пример поиска:**
```sh
grep -rnw . -e 'mlx_put_image_to_window'
```

**Вывод:**  
Судя по стеку, изображение создаётся и выводится через MiniLibX, а не через stdout.  
Чтобы сохранить изображение в файл, ищите или добавьте функцию, которая экспортирует image buffer (например, в PPM/BMP) после рендера, используя данные, полученные через `mlx_get_data_addr` или аналогичную функцию.

---

**Если у вас используется MiniLibX:**  
Обычно изображение выводится функцией `mlx_put_image_to_window`.  
Чтобы быстро найти её использование, выполните в терминале из корня проекта:

```sh
grep -rnw . -e 'mlx_put_image_to_window'
```

Также полезно искать создание изображения:

```sh
grep -rnw . -e 'mlx_new_image'
```

или работу с буфером:

```sh
grep -rnw . -e 'mlx_get_data_addr'
```

Это поможет найти место, где ваша программа формирует и выводит изображение на экран.