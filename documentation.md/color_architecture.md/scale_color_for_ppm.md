Как реализовать скейлинг для PPM
Скейлинг:
Для каждого компонента цвета (R, G, B) умножьте значение (обычно float или double, например 0.0–1.0) на максимальное значение цвета (обычно 255).

c
int scaled = (int)(component * 255.0 + 0.5);
Клампинг:
Если результат меньше 0, присвойте 0. Если больше 255 — присвойте 255.

c
if (scaled < 0) scaled = 0;
if (scaled > 255) scaled = 255;
Запись:
После этого запишите три компонента через пробел, для каждого пикселя, и переходите на новую строку после каждой строки изображения.

Пример функции скейлинга
c
int	scaled_color(float component)
{
	int	value;

	value = (int)(component * 255.0 + 0.5);
	if (value < 0)
		value = 0;
	if (value > 255)
		value = 255;
	return (value);
}
Как использовать при записи PPM
В функции, которая пишет пиксели, для каждого пикселя:

c
for (int y = 0; y < image->height; y++)
{
	for (int x = 0; x < image->width; x++)
	{
		t_color color = get_pixel(image, x, y); // например, структура с float r, g, b
		ft_putnbr_fd(scaled_color(color.r), fd);
		ft_putchar_fd(' ', fd);
		ft_putnbr_fd(scaled_color(color.g), fd);
		ft_putchar_fd(' ', fd);
		ft_putnbr_fd(scaled_color(color.b), fd);
		if (x < image->width - 1)
			ft_putchar_fd(' ', fd);
	}
	ft_putchar_fd('\n', fd);
}
Итоги
Каждый компонент цвета умножается на 255 и округляется.

Значение ограничивается диапазоном .

Полученные значения записываются в файл как целые числа, разделённые пробелами.

После каждой строки пикселей — перевод строки.

P.S. Не забудьте, что по стандарту PPM ни одна строка не должна быть длиннее 70 символов, но большинство просмотрщиков PPM это игнорируют. Для начала можно не заморачиваться этим, а потом добавить разбиение строк, если потребуется.