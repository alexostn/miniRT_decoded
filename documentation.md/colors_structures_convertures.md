. Разделение структур t_color и t_tuple:

t_tuple лучше использовать только для геометрических операций (векторы, точки, нормали), как рекомендовано в книге Jamis Buck

t_color стоит зарезервировать специально для работы с цветом, включая альфа-канал

2. Оптимизация структур:

c
// colors.h
typedef struct s_color {
    double r;  // [0.0, 1.0]
    double g;
    double b;
    double a;  // для будущего использования (прозрачность/отражение)
} t_color;

// tuples.h (векторные операции)
typedef struct s_tuple {
    double x;
    double y;
    double z;
    double w;  // 0.0 для векторов, 1.0 для точек
} t_tuple;
3. Конверсионные функции:

c
t_color tuple_to_color(t_tuple tuple) {
    return (t_color){tuple.x, tuple.y, tuple.z, 0.0};
}

t_tuple color_to_tuple(t_color color) {
    return (tuple(color.r, color.g, color.b, color.a));
}
4. Работа с miniLibX:

Для вывода в минибиблиотеку добавьте функцию конвертации в ARGB:

c
int color_to_argb(t_color color) {
    int r = (int)(color.r * 255);
    int g = (int)(color.g * 255);
    int b = (int)(color.b * 255);
    return (0xFF << 24) | (r << 16) | (g << 8) | b;
}
Преимущества такого подхода:

Четкое разделение ответственности структур

Возможность добавить специфичные для цвета операции (гамма-коррекция, блендинг)

Упрощение работы с прозрачностью и отражениями в будущем

Соответствие нормативам 42 (избегание смешивания типов)

Рекомендация: Используйте t_color везде, где работаете с цветами объектов и света, а t_tuple — для геометрических вычислений. Это сохранит архитектуру чистой и позволит легко расширять функционал.
**********************************************************
Почему не стоит сразу работать с int
1. Точность и удобство вычислений

В процессе рендеринга все основные операции над цветами (сложение, умножение, смешивание, освещение, отражения) выполняются с плавающей точкой, чтобы избежать потерь точности и эффекта округления на каждом этапе.

Если использовать int сразу, любые промежуточные результаты будут терять точность, и итоговая картинка будет выглядеть хуже из-за кумулятивных ошибок округления.

2. Гибкость

Цвета в raytracer-е могут временно выходить за диапазон  (например, при сложении нескольких источников света или наложении эффектов). Если вы храните цвет в int, вы вынуждены сразу ограничивать значения, что мешает корректно реализовать эффекты вроде bloom, HDR и т.п.

Только на этапе вывода (или записи в файл, или передачи в miniLibX) цвет приводится к int с учетом ограничения диапазона (clamping) и гамма-коррекции, если она нужна.

3. Соответствие архитектуре raytracer'а

В книге "The Raytracer Challenge" цвета изначально реализуются как кортежи с double-компонентами, и только при сохранении изображения в файл (или выводе) происходит преобразование в int.

Такой подход облегчает тестирование, расширение и повторное использование кода: вы можете легко реализовать разные способы вывода (PPM, BMP, miniLibX, PNG и т.д.), просто добавив нужную функцию конвертации.

4. Соответствие требованиям miniRT

В миниRT (см. subject) цвета объектов и света задаются в формате 0-255, но внутри программы вы должны оперировать нормализованными значениями для удобства математики и только при выводе преобразовывать их обратно в int.

Когда можно использовать int сразу
Только если вы пишете очень простой рендерер, где нет сложных цветовых вычислений и все операции — это просто копирование цвета из файла в буфер.

В любом raytracer'е, где есть освещение, смешивание, эффекты — такой подход не сработает и приведет к ошибкам и некачественному изображению.

Использовать конвертацию между float/double и int — не излишне, а совершенно необходимо для корректной работы raytracer-а. Это стандартная практика, позволяющая сохранить точность и гибкость всех цветовых вычислений, а также облегчить поддержку и развитие кода.

Если вы сразу будете работать только с int, вы потеряете точность, гибкость и возможность реализовать многие фичи, которые требуются даже в простейшем raytracer-е.

Этап				Формат хранения цвета		Операции
Внутри raytracer'а	t_color (float/double)		Математика, свет
Перед выводом		t_color → int (ARGB/RGB)	Округление, clamp
В miniLibX/PPM		int (0-255 на канал)		Вывод

***************************************************************************
int color_to_rgba(t_color color)
{
	int r = (int)(color.r * 255);
	int g = (int)(color.g * 255);
	int b = (int)(color.b * 255);
	return (0xFF << 24) | (r << 16) | (g << 8) | b;
}

| 31-24 (Alpha) | 23-16 (Red) | 15-8 (Green) | 7-0 (Blue) |
|     0xFF      |     r       |      g       |     b      |

0xFF << 24: Устанавливает альфа-канал (прозрачность) в максимальное значение (0xFF = 255 = полностью непрозрачный)

r << 16: Сдвигает красный канал на 16 бит влево (позиции 16-23)

g << 8: Сдвигает зелёный канал на 8 бит влево (позиции 8-15)

b: Синий канал остаётся в младших 8 битах (позиции 0-7)

Пример для цвета (0.5, 1.0, 0.0):

r = 0.5 * 255 = 127

g = 1.0 * 255 = 255

b = 0.0 * 255 = 0

Результат: 0xFF << 24 = 0xFF000000, 127 << 16 = 0x007F0000, 255 << 8 = 0x0000FF00, 0 = 0x00000000
Итог: 0xFF7FFF00 (ARGB: 255,127,255,0)

*****************************************************************************************
Оптимальный подход для реализации write_pixel в miniRT:

1. Представление цвета в проекте:
Внутри программы используйте t_color с double (диапазон [0.0, 1.0]) для всех вычислений (освещение, отражения и т.д.).

При выводе в miniLibX конвертируйте в int ARGB (0-255 на канал) через color_to_int().

В .rt-файлах цвета задаются как 0-255 → при парсинге нормализуйте их в t_color через color_c(r/255, g/255, b/255).

2. Функция write_pixel:
c
void write_pixel(t_canvas *canvas, int x, int y, t_color color) 
{
    if (x < 0 || x >= canvas->width || y < 0 || y >= canvas->height)
        return;

    // Применяем clamp и конвертацию в ARGB
    int argb = color_to_argb(&color);
    canvas->pixels[y * canvas->width + x] = argb;
}
3. Функция color_to_argb с clamp и округлением:
c
int color_to_argb(t_color *c) 
{
    double r = fmax(0.0, fmin(1.0, c->r)); // clamp
    double g = fmax(0.0, fmin(1.0, c->g));
    double b = fmax(0.0, fmin(1.0, c->b));
    
    return (0xFF << 24) | // Альфа (непрозрачность)
           ((int)(r * 255 + 0.5) << 16) | // Округление
           ((int)(g * 255 + 0.5) << 8)  |
           (int)(b * 255 + 0.5);
}
4. Ключевые моменты:
Clamp обязателен перед конвертацией, чтобы избежать переполнений (например, при HDR > 1.0 или отрицательных значениях).

Округление через + 0.5 точнее, чем round(), и не требует <math.h> (важно для нормы 42).

Структура t_canvas должна содержать массив int *pixels для ARGB-значений, совместимый с miniLibX.

5. Парсинг цветов из .rt-файла:
c
t_color parse_color(int r, int g, int b) 
{
    return (t_color){
        .r = r / 255.0,
        .g = g / 255.0,
        .b = b / 255.0,
        .a = 1.0 // По умолчанию
    };
}
Итог:

Все внутренние вычисления — в double [0.0, 1.0].

Конвертация в int с clamp/округлением только на этапе вывода.

Соответствует требованиям miniRT и норме 42 (никаких for, switch, глобальных переменных).

*********************************************************
// Calculate offset in the buffer taking into account line alignment
Пояснение:
В графических буферах (например, MiniLibX) строки изображения часто выравниваются, поэтому для доступа к пикселю по координатам (x, y) необходимо учитывать длину строки и выравнивание. Пример:

c
// Пример на C: вычисление смещения для пикселя (x, y)
int offset = y * line_length + x * (bits_per_pixel / 8);
Здесь line_length — длина строки в байтах, а bits_per_pixel — глубина цвета.

Этот подход обеспечивает корректный доступ к пикселям в буфере изображения.