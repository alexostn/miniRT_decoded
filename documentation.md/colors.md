На данном этапе, когда вы только начинаете работать с цветами, создание отдельной директории src/colors может быть избыточным. Логичнее интегрировать функциональность, связанную с цветами, в существующий модуль src/tuples или создать файлы color.c и color.h (или аналогичные, соответствующие нормам именования вашего проекта) внутри src/tuples. Это позволит сохранить связанную логику вместе, так как цвета в концепции книги являются частным случаем кортежей.

**************************************************************

Наиболее практичным подходом будет следующий:

Внутренние вычисления: Используйте нормализованные значения с плавающей точкой в диапазоне от 0.0 до 1.0 для всех внутренних расчетов (освещение, материалы, смешивание цветов и т.д.). Это соответствует подходу книги и является стандартом для большинства алгоритмов трассировки лучей, обеспечивая лучшую точность и простоту реализации математических формул.

Чтение из файла сцены: При парсинге файла .rt считывайте значения цвета как целые числа в диапазоне 0-255. Сразу после чтения преобразуйте их в диапазон 0.0-1.0 (например, путем деления на 255.0) для внутреннего использования и хранения.

Вывод изображения: Перед отображением финального изображения (например, при передаче данных о пикселях в miniLibX) преобразуйте внутренние значения цвета (0.0-1.0) обратно в диапазон 0-255. Это включает умножение на 255, отсечение значений (clamping) к диапазону и округление до целых чисел.

Такой подход позволит вам следовать логике вычислений из книги и одновременно удовлетворять требованиям формата входных данных и, вероятно, выходных данных для отображения в miniRT.
*****************************************************
" less than 0 or increasing it
to greater than 1 at any point along the way. Limiting the color prematurely
can make parts of your scene too bright or dark in the final image "
*****************************************************
Лёгкость расширения
В будущем можно добавить функции вроде:

//TODO: think about linked list for multiple:
t_tuple blend_colors(t_tuple c1, t_tuple c2); // Смешивание цветов
t_tuple color_from_hex(const char *hex);      // Цвет из HEX-строки

***************************************************
обавьте функцию для поэлементного умножения (Hadamard product), если её ещё нет, потому что она часто используется именно для цвета и не совпадает с обычным dot/cross product:

c
t_tuple	hadamard(t_tuple a, t_tuple b)
{
    return (vector(a.x * b.x, a.y * b.y, a.z * b.z));
}

<!-- То же что и : -->
t_tuple	hadamard_product(t_tuple a, t_tuple b)
{
    t_tuple tproduct;

    tproduct.x = a.x * b.x;
    tproduct.y = a.y * b.y;
    tproduct.z = a.z * b.z;
    tproduct.w = 0.0;
    return (tproduct);
}
<!-- 
Для финального вывода в MLX — функция, переводящая tuple (color) в int RGB: -->

c
int	tuple_to_rgb_int(t_tuple c)
{
    int	r = clamp(c.x * 255.0, 0, 255);
    int	g = clamp(c.y * 255.0, 0, 255);
    int	b = clamp(c.z * 255.0, 0, 255);
    return ((r << 16) | (g << 8) | b);
}
<!-- Где clamp — простая функция ограничения значения -->

**********************************************************
В теории (согласно книге) цвета — трёхкомпонентные векторы (RGB)

Но miniLibX работает с 32-битными цветами (ARGB), где:

c
// Формат: 0xAARRGGBB
#define ALPHA 0xFF000000
#define RED   0x00FF0000
#define GREEN 0x0000FF00 
#define BLUE  0x000000FF
Специфика вашего кода
Для конвертации в формат mlx используйте:
**********************************************************
typedef struct s_color {
    float r; // [0.0, 1.0]
    float g;
    float b;
    float a; // альфа-канал (1.0 = непрозрачность)
} t_color;

int color_to_int(t_color *c) {
    return ((int)(c->a * 255) << 24) | 
           ((int)(c->r * 255) << 16) | 
           ((int)(c->g * 255) << 8)  | 
           (int)(c->b * 255);
}

1. Разделение логики
Для векторных операций (свет, отражения) оставьте текущую реализацию, но переименуйте функцию для ясности:

c
t_tuple rgb(double r, double g, double b) {
    return tuple(r, g, b, 0.0);  // w=0.0 для векторных вычислений
}
Для вывода в miniLibX добавьте отдельную структуру с альфа-каналом:

c
typedef struct s_color {
    float r;    // [0.0, 1.0]
    float g;
    float b;
    float a;    // Альфа-канал (1.0 = непрозрачность)
} t_color;
2. Конвертация в ARGB
Создайте функцию преобразования для miniLibX:

c
int color_to_int(t_color *c) {
    return ((int)(c->a * 255) << 24) | 
           ((int)(c->r * 255) << 16) | 
           ((int)(c->g * 255) << 8)  | 
           (int)(c->b * 255);
}
3. Пример использования
c
// Для вычислений (векторная модель)
t_tuple red_vec = rgb(1.0, 0.0, 0.0);  // w=0.0

// Для вывода (ARGB)
t_color red_mlx = {
    .r = red_vec.x,
    .g = red_vec.y,
    .b = red_vec.z,
    .a = 1.0  // Обязательно для miniLibX!
};
image_write_pixel(canvas, x, y, color_to_int(&red_mlx));
4. Проверка требований проекта
Структуры с префиксом t_: t_color соответствует нормам 42.

Отсутствие утечек: color_to_int не выделяет память, что соответствует требованию "no leaks".

Форматирование: Использование табуляции (4 символа) и snake_case имён соблюдено.

Итог:
Используйте rgb() для внутренних вычислений (векторы) и color_to_int() для вывода в miniLibX (ARGB). Это обеспечит корректную работу с графической библиотекой без нарушения математической модели из книги.

Related

**********************************************************
. Разделение структур t_color и t_tuple:

t_tuple лучше использовать только для геометрических операций (векторы, точки, нормали), как рекомендовано в книге Jamis Buck

t_color стоит зарезервировать специально для работы с цветом, включая альфа-канал

2. Оптимизация структур:

c
// colors.h
typedef struct s_color {
    double r;  // [0.0, 1.0]
    double g;
    double b;
    double a;  // для будущего использования (прозрачность/отражение)
} t_color;

// tuples.h (векторные операции)
typedef struct s_tuple {
    double x;
    double y;
    double z;
    double w;  // 0.0 для векторов, 1.0 для точек
} t_tuple;
3. Конверсионные функции:

c
t_color tuple_to_color(t_tuple tuple) {
    return (t_color){tuple.x, tuple.y, tuple.z, 0.0};
}

t_tuple color_to_tuple(t_color color) {
    return (tuple(color.r, color.g, color.b, color.a));
}
4. Работа с miniLibX:

Для вывода в минибиблиотеку добавьте функцию конвертации в ARGB:

c
int color_to_argb(t_color color) {
    int r = (int)(color.r * 255);
    int g = (int)(color.g * 255);
    int b = (int)(color.b * 255);
    return (0xFF << 24) | (r << 16) | (g << 8) | b;
}
Преимущества такого подхода:

Четкое разделение ответственности структур

Возможность добавить специфичные для цвета операции (гамма-коррекция, блендинг)

Упрощение работы с прозрачностью и отражениями в будущем

Соответствие нормативам 42 (избегание смешивания типов)

Рекомендация: Используйте t_color везде, где работаете с цветами объектов и света, а t_tuple — для геометрических вычислений. Это сохранит архитектуру чистой и позволит легко расширять функционал.
